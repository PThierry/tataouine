# This makefile manage the configuration related targets and variables.
# This file consider that the current project is based on Kconfig to
# manage its sources and configuration
# the config file is still '.config' and is sourced here.


# basic. The config file name is set here and _only_ here. Its existance is
# checked before including it
# for letter config check existance, the CONFIG_DONE var is tested
# (mandatory variable of the .confg file)
# PROJ_FILE is used to allow Makefiles in subdirs to source this file. They must
# set PROJ_FILE according to the source root directory, where both .config and
# config.mk are set

ifeq ($(PROJ_FILES),)
PROJ_FILES = ./
CONFIGFILE = .config
else
CONFIGFILE = $(PROJ_FILES).config
endif

# detect if the .config file exists, or just include... nothing
ifneq ($(wildcard $(CONFIGFILE)),)
include $(CONFIGFILE)
endif

# defining toolchain related values based on configuration

# these three variables can be overloaded by the make call. For e.g. you can
# execute:
# ADA_RUNTIME=/my/ada/toolchain/path CROSS_COMPILE=arm-eabi- make
#
ADAKERNEL     ?= $(CONFIG_ADAKERNEL)
ADA_RUNTIME   ?= $(ADA_RUNTIME:"%"=%)
CROSS_COMPILE ?= $(CROSS_COMPILE:"%"=%)
ARCH          ?= $(CONFIG_ARCH:"%"=%)
ifneq (y,$(USE_LLVM))
CC             = $(CROSS_COMPILE)gcc
else
CC             = $(CLANG_PATH)
endif
LD             = $(CROSS_COMPILE)ld
AR             = $(CROSS_COMPILE)ar
OBJCOPY        = $(CROSS_COMPILE)objcopy
GDB            = $(CROSS_COMPILE)gdb
RANLIB         = $(CROSS_COMPILE)ranlib
RM             = rm
RMFLAGS       ?= -rf

# Replace this with proper Makefile substitution
# for GCC compilation
CFLAGS_GCC     += $(subst ",, $(CONFIG_AFLAGS_GCC))
CFLAGS_GCC     += $(subst ",, $(CONFIG_WARNFLAGS_GCC))
CFLAGS_GCC     += $(subst ",, $(CONFIG_EMBEDCFLAGS))
CFLAGS_GCC     += $(subst ",, $(CONFIG_DBGFLAGS_GCC))

AFLAGS_GCC     = $(subst ",, $(CONFIG_AFLAGS_GCC))
WARN_CFLAGS_GCC  = $(subst ",, $(CONFIG_WARNFLAGS_GCC))

# for LLVM compilation
CFLAGS_LLVM    += $(subst ",, $(CONFIG_AFLAGS_LLVM))
CFLAGS_LLVM    += $(subst ",, $(CONFIG_WARNFLAGS_LLVM))
CFLAGS_LLVM    += $(subst ",, $(CONFIG_EMBEDCFLAGS))
CFLAGS_LLVM    += $(subst ",, $(CONFIG_DBGFLAGS_LLVM))

AFLAGS_LLVM    = $(subst ",, $(CONFIG_AFLAGS_LLVM))
WARN_CFLAGS_LLVM = $(subst ",, $(CONFIG_WARNFLAGS_LLVM))

ifneq (y,$(USE_LLVM))
CFLAGS         := $(CFLAGS_GCC)
AFLAGS         := $(AFLAGS_GCC)
WARN_CFLAGS    := $(WARN_FLAGS_GCC)
else
CFLAGS         := $(CFLAGS_LLVM)
AFLAGS         := $(AFLAGS_LLVM)
WARN_CFLAGS    := $(WARN_FLAGS_LLVM)
endif
# this flag clean unused data/functions from firmware
# beware, it delete the allocator pool
#LDFLAGS       += -Wl,--gc-sections

DEBUG_CFLAGS   = $(subst ",, $(CONFIG_DBGFLAGS))
EMBED_CFLAGS   = $(subst ",, $(CONFIG_EMBEDCFLAGS))
HARDEN_CFLAGS  = $(subst ",, $(CONFIG_STACKPROTFLAGS))
KERN_CFLAGS  = $(subst ",, $(CONFIG_KERN_CFLAGS))

DRIVERS_CFLAGS  = $(subst ",, $(CONFIG_DRIVERS_CFLAGS))
LIB_CFLAGS    = $(shell var=""; for i in `cat $(PROJ_FILES)/.config |grep "USR_LIB_.*CFLAGS"|cut -d'=' -f 2|cut -d' ' -f 2`; do var="$$var $$i"; done; echo $$var -I../../libs/std)
DRV_CFLAGS    = $(shell var=""; for i in `cat $(PROJ_FILES)/.config |grep "USR_DRV_.*CFLAGS"|cut -d'=' -f 2|cut -d' ' -f 2`; do var="$$var $$i"; done; echo $$var)
#DRV_CFLAGS    = $(subst ",, $(CONFIG_DRV_CFLAGS))

APPS_CFLAGS    = $(DEBUG_CFLAGS) $(AFLAGS) $(CFLAGS) -I$(PROJ_FILES) $(LIB_CFLAGS) $(DRV_CFLAGS) -fstack-protector-strong

LIB_OPTIM_CFLAGS = $(subst ",, $(CONFIG_LIB_OPTIM_CFLAGS))

# About libecc
ECC_DIR        = $(PROJ_FILES)/$(subst ",,$(CONFIG_ECC_DIR))

ECC_CURVENAME  = $(CONFIG_ECC_CURVNAME:"%"=%)

# About the tokens
AUTH_TOKEN_MAX_PIN  = $(CONFIG_AUTH_TOKEN_MAX_PIN:"%"=%)
AUTH_TOKEN_MAX_SC   = $(CONFIG_AUTH_TOKEN_MAX_SC:"%"=%)
AUTH_TOKEN_PET_PIN  = $(CONFIG_AUTH_TOKEN_PET_PIN:"%"=%)
AUTH_TOKEN_USER_PIN = $(CONFIG_AUTH_TOKEN_USER_PIN:"%"=%)
AUTH_TOKEN_PET_NAME = $(CONFIG_AUTH_TOKEN_PET_NAME:"%"=%)

DFU_TOKEN_MAX_PIN  = $(CONFIG_DFU_TOKEN_MAX_PIN:"%"=%)
DFU_TOKEN_MAX_SC   = $(CONFIG_DFU_TOKEN_MAX_SC:"%"=%)
DFU_TOKEN_PET_PIN  = $(CONFIG_DFU_TOKEN_PET_PIN:"%"=%)
DFU_TOKEN_USER_PIN = $(CONFIG_DFU_TOKEN_USER_PIN:"%"=%)
DFU_TOKEN_PET_NAME = $(CONFIG_DFU_TOKEN_PET_NAME:"%"=%)

USE_DIFFERENT_PHYSICAL_TOKENS = $(CONFIG_USE_DIFFERENT_PHYSICAL_TOKENS:"%"=%)

ifeq ("$(CONFIG_USE_SIG_TOKEN_BOOL)","y")
        USE_SIG_TOKEN = USE_SIG_TOKEN
        SIG_TOKEN_MAX_PIN  = $(CONFIG_SIG_TOKEN_MAX_PIN:"%"=%)
        SIG_TOKEN_MAX_SC   = $(CONFIG_SIG_TOKEN_MAX_SC:"%"=%)
        SIG_TOKEN_PET_PIN  = $(CONFIG_SIG_TOKEN_PET_PIN:"%"=%)
        SIG_TOKEN_USER_PIN = $(CONFIG_SIG_TOKEN_USER_PIN:"%"=%)
        SIG_TOKEN_PET_NAME = $(CONFIG_SIG_TOKEN_PET_NAME:"%"=%)
else
        USE_SIG_TOKEN = NO_SIG_TOKEN
        LOCAL_PASSWORD = $(CONFIG_LOCAL_PASSWORD:"%"=%)
endif

##### Handle the libsign CFLAGS
# We use SHA-256 and SHA-512 in various places in our embedded platform
LIBSIGN_CFLAGS = -MMD -MP -DWITH_LIBECC_CONFIG_OVERRIDE -DUSE_SIG_BLINDING -DWITH_HASH_SHA256 -DWITH_HASH_SHA512
# We are bound to use ECDSA as a signature algorithm because tokens lack support of other
# algorithms ...
LIBSIGN_CFLAGS += -DWITH_SIG_ECDSA
# The choice of the 256-bit curve is left to the user
ifeq ("$(CONFIG_ECC_CURVENAME_FR256)","y")
        LIBSIGN_CFLAGS += -DWITH_CURVE_FRP256V1
endif
ifeq ("$(CONFIG_ECC_CURVENAME_SP256)","y")
        LIBSIGN_CFLAGS += -DWITH_CURVE_SECP256R1
endif
ifeq ("$(CONFIG_ECC_CURVENAME_BP256)","y")
        LIBSIGN_CFLAGS += -DWITH_CURVE_BRAINPOOLP256R1
endif

# FIXME: should be replaced by a real external projects support
EXTERNAL_CFLAGS = -I$(PROJ_FILES)/libs/libecc/src

# export to all make call through environment
export ARCH CC AR LD OBJCOPY GDB RANLIB CROSS_COMPILE

# in case .config is not set, to build kconfig-frontends in a given build_dir.
# this hack will be replaced by an external installation of kconfig-frontends
# instead of a local submodule
ifeq ("$(CONFIG_BUILD_DIR)","")
BUILD_DIR      = $(PROJ_FILES)build/unconfigured
else
BUILD_DIR      = $(PROJ_FILES)$(CONFIG_BUILD_DIR:"%"=%)/$(ARCH)/$(BOARD)
PRIVATE_DIR      = $(PROJ_FILES)/$(CONFIG_PRIVATE_DIR:"%"=%)
endif
CFLAGS        += -I$(PRIVATE_DIR)

LDFLAGS          ?=
LDFLAGS          += -L$(BUILD_DIR)
ifneq ($(APP_BUILD_DIR),)
LDFLAGS          += -L$(APP_BUILD_DIR)
endif
#LDFLAGS          += $(patsubst %, -l%, $(wildcard $(BUILD_DIR)/libs/*))
#LDFLAGS          += -mfloat-abi=hard -mfpu=fpv4-sp-d16
#LDFLAGS          += -fshort-enums
TODEL             =
RTS            = zfp-stp32f4

# defining target related options based on configuration
BOARD          = $(CONFIG_BOARDNAME:"%"=%)
SOC            = $(CONFIG_SOCNAME:"%"=%)

LIBSIGN        = $(BUILD_DIR)/libsign.a

KEYS_DIR       = $(PRIVATE_DIR)
KEYS_PREFIX    = $(CONFIG_PROJ_NAME:"%"=%)
KEYS_PATH      = $(KEYS_DIR)/$(KEYS_PREFIX)
TOKEN_KEYS_PATH=$(KEYS_DIR)/

KEY2HEADER = $(PROJ_FILES)/tools/key2header.py
KEY2JAVA = $(PROJ_FILES)/tools/key2java.py
GENKEYS = $(PROJ_FILES)/tools/gen_keys.py
SIGNFIRMWARE = $(PROJ_FILES)/tools/encrypt_sign_firmware.py
VERIFYFIRMWARE = $(PROJ_FILES)/tools/decrypt_verify_firmware.py

MKDIR = mkdir -p

# FIXME: deprecated, to set elsewhere or to delete
# and replace
DRVUSB_SRC     = peripherals/usb/stm32f4xx_usb_fs.c

# in case these vars doesn't exists yet
CONFIG_ECC_DIR?   = $(PROJ_FILES)libs/libecc

PWD=$(shell pwd)
# MCONF and CONF tools, generated by prepare_config
ifeq (, $(shell which kconfig-conf))
# using python kconfiglib tool
MCONF            ?= menuconfig
CONF             ?= oldconfig
CONF_ARGS        ?=
CONFGEN          ?= genconfig
CONFGEN_ARGS     ?= --header-path include/generated/autoconf.h
else
# using kconfig-frontend
MCONF            ?= kconfig-mconf
CONF             ?= kconfig-conf
CONF_ARGS        ?= --silentoldconfig
CONFGEN          ?= true
CONFGEN_ARGS     ?= 
endif

EC_UTILS          = $(BUILD_DIR)/tools/ec_utils

STFLASH           ?= $(ST_FLASH)
STUTIL            ?= $(ST_UTIL)
