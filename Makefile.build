# This file define the verbose and quiet versions of each compilation/link/objcopy etc. action
# this file can be increase as needed to adapt the root and leaf Makefile accordingly
# This permits to support both quiet execution (standard mode) and verbose execution (using V=1 or V=2)
#
# When using silent mode, all action is written in the corresponding file (relative to $@) prefixed with a
# dot and finishing with a .cmd (same as the Linux kernel) to be able to read what command as been executed
#
# basic usage:
# there is two definition: the command itself and its pretty printing for the silent mode
# the command itself is always executed, but printed only in verbose mode (V>=1)
#
# to call a command depending on the prerequisites (typically for compilation, to detect change in any
# prerequisite files, use the following syntax:
# $(call if_changed,<command>) e.g. : $(call if_changed,cc_o_c)
#
# to call a command at each time (typically a clean or menuconfig target, use the following
# syntax:
# $(call cmd,<command>) e.g. : $(call cmd,clean)
#
# For advanced usage, read the tools/Kconfig.include file

# classical C Compiling (c => o)
quiet_cmd_cc_o_c        = CC       $@
      cmd_cc_o_c        = test -d $(dir $@) || mkdir -p $(dir $@); $(CC) $< -c $(CFLAGS) -o $@

quiet_cmd_ada_lib       = ADA      $@
      cmd_ada_lib       = ADA_ARCH=$(CONFIG_ADA_ARCH) ADA_RUNTIME=$(ADA_RUNTIME) ADA_PROFILE=$(CONFIG_ADA_PROFILE) BUILD_DIR=$(APP_BUILD_DIR) ARCH=$(CONFIG_ARCH) SOCNAME=$(CONFIG_SOCNAME) gprbuild -P$<

quiet_cmd_ada_clean     = ADACLEAN $<
      cmd_ada_clean     = ADA_ARCH=$(CONFIG_ADA_ARCH) ADA_RUNTIME=$(ADA_RUNTIME) ADA_PROFILE=$(CONFIG_ADA_PROFILE) BUILD_DIR=$(APP_BUILD_DIR) ARCH=$(CONFIG_ARCH) SOCNAME=$(CONFIG_SOCNAME) gprclean -c -P$< >/dev/null 2>&1

quiet_cmd_ada_distclean = ADADCLEAN $<
      cmd_ada_distclean = ADA_ARCH=$(CONFIG_ADA_ARCH) ADA_RUNTIME=$(ADA_RUNTIME) ADA_PROFILE=$(CONFIG_ADA_PROFILE) BUILD_DIR=$(APP_BUILD_DIR) ARCH=$(CONFIG_ARCH) SOCNAME=$(CONFIG_SOCNAME) gprclean -P$< >/dev/null 2>&1

# classical Ada Compiling (adb => o)
quiet_cmd_gnat_o_ada    = GNAT     $@
      cmd_gnat_o_ada    = arm-eabi-gnatmake -gnat2012 --RTS=$(RTS) -c -cargs -c $(CONFIG_AFLAGS) -i $< -o $@ 

# managing fw and dfu build for apps
quiet_cmd_buildapp      = APP     $@
      cmd_buildapp      = cp $(BUILD_DIR)/libs/*/lib*.a $(BUILD_DIR)/apps/$@; \
						  cp $(BUILD_DIR)/drivers/*/lib*.a $(BUILD_DIR)/apps/$@; \
						  if [ -f $(BUILD_DIR)/apps/$@/$@.fw1.ld ]; then make -C $@ all EXTRA_LDFLAGS=-T$@.fw1.ld APP_NAME=$@.fw1; fi; \
						  if [ ! -z "$(CONFIG_FIRMWARE_DUALBANK)" ]; then if [ -f $(BUILD_DIR)/apps/$@/$@.fw2.ld ]; then make -C $@ all EXTRA_LDFLAGS=-T$@.fw2.ld APP_NAME=$@.fw2; fi; fi; \
						  if [ -f $(BUILD_DIR)/apps/$@/$@.dfu1.ld ]; then make -C $@ all EXTRA_LDFLAGS=-T$@.dfu1.ld APP_NAME=$@.dfu1; fi; \
						  if [ ! -z "$(CONFIG_FIRMWARE_DUALBANK)" ]; then if [ -f $(BUILD_DIR)/apps/$@/$@.dfu2.ld ]; then make -C $@ all EXTRA_LDFLAGS=-T$@.dfu2.ld APP_NAME=$@.dfu2; fi; fi

# linking
quiet_cmd_ldscript      = LDSCRIPT $@
      cmd_ldscript      = $(PROJ_FILES)tools/gen_app_ld.pl $(BUILD_DIR) $(PROJ_FILES)/.config

# linking
quiet_cmd_k_ldscript    = LDSCRIPT $@
      cmd_k_ldscript    = sed -e 's:BUILDDIR:$(BUILD_DIR):g' $(APP_NAME).ld.in | sed -e 's:APP_NAME:$(APP_NAME):g' > $(APP_BUILD_DIR)/$(APP_NAME).ld

# classical Ada Compiling (adb => o)
quiet_cmd_gnat_o_ali    = GNATBIND $@
      cmd_gnat_o_ali    = arm-eabi-gnatmake -gnat2012 --RTS=$(RTS) -b -bargs -n $(AALI) 

# linking
# gcc symbols (see cc_a_syms) must be prefixed again here, to avoid collision
# of syms when generating the firmware. as they are resolved at link time,
# they can be prefixed after without arm
quiet_cmd_link_o_target = LD       $@
      cmd_link_o_target = $(CC) $(LDFLAGS) $(ARCH_OBJ) $(ROBJ) $(SOBJ) $(OBJ) $(DRVOBJ) $(CORE_OBJ) $(SOC_OBJ) $(BOARD_OBJ) $(LD_LIBS) -o $@

# ADA linking
quiet_cmd_adalink_o_target = ADALD    $@
      cmd_adalink_o_target = arm-eabi-gnatmake -gnat2012 --RTS=$(RTS) -l -largs $(LD_LIBS) $(LDFLAGS) $(lastword $(AALI)) $(ARCH_OBJ) $(ROBJ) $(SOBJ) $(OBJ) $(DRVOBJ) $(CORE_OBJ) $(SOC_OBJ) $(BOARD_OBJ) -o $@

#####################################################################
# Kernel headers generation
#  Ewok is based on some autogenerated headers for application permissions
#  and layout. These headers are assumed to exist by the kernel build system
#  and are generated here.
#

quiet_cmd_prepare_kernel_header_for_fw1 = KERNHEADER_FW1
      cmd_prepare_kernel_header_for_fw1 = \
         ./tools/gen_ld.pl $(CONFIG_ARCH) $(CONFIG_BOARDNAME) $(BUILD_DIR)/apps_sections.fw1.ld fw1 $(PROJ_FILES)/.config; \
		 ./tools/gen_symhdr.pl $(CONFIG_ARCH) $(CONFIG_BOARDNAME) fw1 .config; \
	     ./tools/apps/permissions.pl FW $(PROJ_FILES)/.config $(PROJ_FILES)/apps/ipc.config $(PROJ_FILES)/apps/dmashm.config

quiet_cmd_prepare_kernel_header_for_fw2 = KERNHEADER_FW2
      cmd_prepare_kernel_header_for_fw2 = \
         ./tools/gen_ld.pl $(CONFIG_ARCH) $(CONFIG_BOARDNAME) $(BUILD_DIR)/apps_sections.fw2.ld fw2 $(PROJ_FILES)/.config; \
		 ./tools/gen_symhdr.pl $(CONFIG_ARCH) $(CONFIG_BOARDNAME) fw2 .config; \
	     ./tools/apps/permissions.pl FW $(PROJ_FILES)/.config $(PROJ_FILES)/apps/ipc.config $(PROJ_FILES)/apps/dmashm.config

quiet_cmd_prepare_kernel_header_for_dfu1 = KERNHEADER_DFU1
      cmd_prepare_kernel_header_for_dfu1 = \
         ./tools/gen_ld.pl $(CONFIG_ARCH) $(CONFIG_BOARDNAME) $(BUILD_DIR)/apps_sections.dfu1.ld dfu1 $(PROJ_FILES)/.config; \
		 ./tools/gen_symhdr.pl $(CONFIG_ARCH) $(CONFIG_BOARDNAME) dfu1 .config; \
	     ./tools/apps/permissions.pl DFU $(PROJ_FILES)/.config $(PROJ_FILES)/apps/ipc.config $(PROJ_FILES)/apps/dmashm.config

quiet_cmd_prepare_kernel_header_for_dfu2 = KERNHEADER_DFU2
      cmd_prepare_kernel_header_for_dfu2 = \
         ./tools/gen_ld.pl $(CONFIG_ARCH) $(CONFIG_BOARDNAME) $(BUILD_DIR)/apps_sections.dfu2.ld dfu2 $(PROJ_FILES)/.config; \
		 ./tools/gen_symhdr.pl $(CONFIG_ARCH) $(CONFIG_BOARDNAME) dfu2 .config; \
	     ./tools/apps/permissions.pl DFU $(PROJ_FILES)/.config $(PROJ_FILES)/apps/ipc.config $(PROJ_FILES)/apps/dmashm.config




# rust compilation
quiet_cmd_rc_o_rs       = RC       $@
      cmd_rc_o_rs       = $(RUSTC) $< --emit obj --target $(TARGET) -L $(LIBCORE_PATH) -o $@


# hex file generation
quiet_cmd_objcopy_ihex  = OBJ/HEX  $@
      cmd_objcopy_ihex  = $(OBJCOPY) -O ihex $< $@

# bin file generation
quiet_cmd_objcopy_bin   = OBJ/BIN  $@
      cmd_objcopy_bin   = $(OBJCOPY) -O binary $< $@

# layout build
quiet_cmd_layout        = LAYOUT   $@
      cmd_layout        = $(CC) $(AFLAGS) $(WARN_CFLAGS) $(EMBED_CFLAGS) -E -x c $(MEM_LAYOUT_DEF) -I. -Iinclude/generated -Ikernel/arch/socs/$(SOC) -Ikernel/arch/cores/$(CONFIG_ARCH) -Ikernel/arch/boards/$(CONFIG_BOARDNAME) $(LDS) $(LDS_GEN) | grep -v '^\#' > $(MEM_LAYOUT); \
                          $(CC) $(AFLAGS) $(WARN_CFLAGS) $(EMBED_CFLAGS) -E -x c $(MEM_APP_LAYOUT_DEF) -I. -Iinclude/generated -Ikernel/arch/socs/$(SOC) -Ikernel/arch/cores/$(CONFIG_ARCH) -Ikernel/arch/boards/$(CONFIG_BOARDNAME) $(LDS) $(LDS_GEN) | grep -v '^\#' > $(MEM_APP_LAYOUT)

# final layout build
quiet_cmd_final_layout  = END/LAY  $@
      cmd_final_layout  = sed -e 's:BUILDDIR:$(BUILD_DIR):g' $< | sed -e 's:APP_NAME:$(APP_NAME):g' > $@

# final elf file generation
quiet_cmd_final_elf     = END/ELF  $@
      cmd_final_elf     = $(LD) -T$< -b elf32-littlearm -o $@ $(BUILD_DIR)/kernel/kernel.elf $(APPS_ELFFILES)

# final hex file generation
quiet_cmd_final_hex     = END/HEX  $@
      cmd_final_hex     = $(BUILDDFU) $^ $@ 0

# final hex file generation
quiet_cmd_final_bin     = END/BIN  $@
      cmd_final_bin     = $(OBJCOPY) -I ihex --output-target=binary $< $@

# make static library
quiet_cmd_mklib         = AR       $@
      cmd_mklib         = $(AR) rcs $@ $(KERNEL_OBJS) $(ARCH_OBJ) $(ROBJ) $(SOBJ) $(OBJ) $(DRVOBJ) $(CORE_OBJ) $(SOC_OBJ) $(BOARD_OBJ) $(ASM_OBJ)

# make static library
quiet_cmd_ranlib        = RANLIB   $@
      cmd_ranlib        = $(RANLIB) $@

# signing binary
quiet_cmd_ec_sign       = SIGN     $(BIN_NAME)
      cmd_ec_sign       = $(EC_UTILS) struct_sign $(ECC_CURVENAME)  $(ECC_SIGNAME) $(ECC_HASHNAME) $(BUILD_DIR)/$(APP_NAME)/$(BIN_NAME) $(KEYS_PATH)_private_key.bin $(BUILD_DIR)/$(APP_NAME)/$(BIN_NAME).sign $(IMAGE_TYPE) $(VERSION)

# verifying the signature
quiet_cmd_ec_verify     = VERIF    $(BIN_NAME)
      cmd_ec_verify     = $(EC_UTILS) struct_verify $(ECC_CURVENAME) $(ECC_SIGNAME) $(ECC_HASHNAME) $(BUILD_DIR)/$(APP_NAME)/$(BIN_NAME).sign $(KEYS_PATH)_public_key.bin

quiet_cmd_mkapplet      = APPLET   $@
      cmd_mkapplet      = mkdir -p $(BUILD_DIR)/javacard/applet; touch $(BUILD_DIR)/javacard/applet/.applet.cmd.ant; cp $(PRIVATE_DIR)/Keys.java $(PROJ_FILES)/javacard/applet/src/goodusb/; cd $(PROJ_FILES)/javacard/applet && ant -Dbuilddir=../$(BUILD_DIR)/javacard/applet -logfile ../$(BUILD_DIR)/javacard/applet/.applet.cmd.ant

# make build directory
quiet_cmd_mkdir         = MKDIR      $@
      cmd_mkdir         = mkdir -p $@

# make build directory
quiet_cmd_rm_builddir   = RMDIR  $(BUILD_DIR)
      cmd_rm_builddir   = if test -d "$(BUILD_DIR)"; then rm -rf $(BUILD_DIR); fi

# generic GNU target
quiet_cmd_clean         = CLEAN
      cmd_clean         = make -C . -npq --no-print-directory .DEFAULT 2>/dev/null |grep -q ^__clean && $(MAKE) __clean; rm -rf $(TODEL_CLEAN)

# generic GNU target
quiet_cmd_distclean     = DISTCLEAN
      cmd_distclean     = make -C . -npq --no-print-directory .DEFAULT 2>/dev/null |grep -q ^__distclean && $(MAKE) __distclean; rm -rf $(TODEL_DISTCLEAN)

# about menuconfig, oldconfig and so on...
quiet_cmd_menuconfig    = MENUCONFIG
      cmd_menuconfig    = $(MCONF) Kconfig

quiet_cmd_mkincludedir  = MKINCLUDEDIR
      cmd_mkincludedir  = mkdir -p $(PWD)/include && mkdir -p $(PWD)/include/config $(PWD)/include/generated

quiet_cmd_pepareada     = PREPAREADA
      cmd_prepareada    = for i in $(shell cat kernel/Ada/libgnat/gnat/link_list.txt); do ln -fs $(ADA_RUNTIME)/arm-eabi/lib/gnat/zfp-stm32f4/gnat/$$i $(PWD)/kernel/Ada/libgnat/gnat/$$i; done
      # as file read is supported only since gmake 1.2, shell read is required here :-/

quiet_cmd_prepare       = PREPARE
      cmd_prepare       = $(CONF) $(CONF_ARGS) Kconfig; ./tools/gen_autoconf_ada.pl .config; \
						  $(CONFGEN) $(CONFGEN_ARGS) Kconfig

# tiny defconfig support, please don't call any other target depending on config here,
# Makefile.conf should be relaoded
quiet_cmd_defconfig     = DEFCONFIG  $@
      cmd_defconfig     = cp configs/$@ .config && $(CONF) $(CONF_ARGS) Kconfig

quiet_cmd_listdefconfig = LISTDEFS   $@
cmd_listdefconfig = find  configs/ -type f -iname '*_defconfig' | sed -e 's:^configs/::g' |sort

# documentation part
quiet_cmd_mkman2        = MAN        $@
      cmd_mkman2        = rst2man --title="EwoK syscalls API"  --no-generator --no-datestamp --no-source-link $</$(patsubst %.2,%.rst,$(notdir $@)) $@ 

quiet_cmd_mkman3        = MAN        $@
      cmd_mkman3        = rst2man --title="EwoK syscalls API"  --no-generator --no-datestamp --no-source-link $</$(patsubst %.3,%.rst,$(notdir $@)) $@ 

quiet_cmd_mkhtml        = HTML       $@
      cmd_mkhtml        = BUILDDIR=../$@ make -C sphinx html >/dev/null 2>&1

quiet_cmd_doxygen       = DOXY       $@
      cmd_doxygen       = cat $< | sed -e 's:BUILDDIR:$(BUILD_DIR):g' | doxygen -; \
			  if [ -d $@/latex ]; then make -C $@/latex >/dev/null 2>&1 && cp $@/latex/refman.pdf $@/`basename $@`.pdf; fi; \
			  if [ -d $@/../sphinx/html ]; then cp $@/`basename $@`.pdf $@/../sphinx/html/_downloads; fi

quiet_cmd_doxy_custom   = DOXY+      $@
      cmd_doxy_custom   = if [ -d $@/latex ]; then ../tools/gen_devmap.pl $(BUILD_DIR) $@/latex/devmap.tex ../kernel/arch/socs/stm32f439/soc-devmap.h; \
			  TMP=`sed -e 's:.*End generated contents.*:\\input{devmap}:g' $@/latex/refman.tex;`; printf "$${TMP}" > $@/latex/refman.tex; unset TMP \
      			  make -C $@/latex >/dev/null 2>&1 && cp $@/latex/refman.pdf $@/`basename $@`.pdf; fi; \
			  if [ -d $@/../sphinx/html/docs ]; then cp $@/`basename $@`.pdf $@/../sphinx/html/_downloads; fi

# as apps are hosted by other repositories, applist is dynamic for Kconfig, and generated here
quiet_cmd_kconf_app_gen = KCONF
      cmd_kconf_app_gen = rm -f $(PROJ_FILES)/apps/Kconfig.gen; for i in $(shell find apps -maxdepth 1 -mindepth 1 -type d ! -iname '.git'); do /bin/echo "source \"$$i/Kconfig\"" >> $(PROJ_FILES)/apps/Kconfig.gen; done


# as drivers are hosted by other repositories, driverlist is dynamic for Kconfig, and generated here.
# The drivers CFLAGS list is also generated here using the below for-llop respecting the CONFIG_USR_DRV_<DRVNAME>_CFLAGS convention, 
# where DRVNAME is the upercase word using the lib<drvname> structure of the driver dir.
quiet_cmd_kconf_drv_gen = KCONF
      cmd_kconf_drv_gen = rm -f $(PROJ_FILES)/drivers/Kconfig.gen; for i in $(shell find drivers -maxdepth 3 -mindepth 3 -type d ! -iname '.git'); do /bin/echo "source \"$$i/Kconfig\"" >> $(PROJ_FILES)/drivers/Kconfig.gen; done;


# as libs are hosted by other repositories, liblist is dynamic for Kconfig, and generated here.
# The drivers CFLAGS list is also generated here using the below for-llop respecting the CONFIG_USR_LIB_<LIBNAME>_CFLAGS convention, 
# where DRVNAME is the upercase word using the lib<drvname> structure of the driver dir.
quiet_cmd_kconf_lib_gen = KCONF
      cmd_kconf_lib_gen = rm -f $(PROJ_FILES)/libs/Kconfig.gen; for i in $(shell find libs -maxdepth 1 -mindepth 1 -type d ! -iname '.git' -a ! -iname common -a ! -iname libbsp -a ! -iname libecc); do /bin/echo "source \"$$i/Kconfig\"" >> $(PROJ_FILES)/libs/Kconfig.gen; done

#
# Depending on the manifest, some Kconfig and Kconfig-associated files may not exsit. If not
# the file is simply 'touched' to avoid menuconfig error.
quiet_cmd_nokconfig  = KCONF
      cmd_nokconfig  = for i in kernel/Kconfig apps/ipc.config apps/dmashm.config; do \
					     if [ ! -e "$$i" ]; then touch "$$i"; fi; \
					   done

quiet_cmd_kconf_root  = KCONF
      cmd_kconf_root  = rm -f $(PROJ_FILES)/Kconfig.gen; if [ -f javacard/Kconfig ]; then /bin/echo "source javacard/Kconfig" > $(PROJ_FILES)/Kconfig.gen; else /bin/echo "" >> $(PROJ_FILES)/Kconfig.gen; fi

# generate makefile.objs directory listing from current list of dirs

quiet_cmd_mkobjlist_libs   = MAKEOBJS_LIBS
      cmd_mkobjlist_libs   = rm -f libs/Makefile.objs.gen; for i in $(shell find libs -mindepth 1 -maxdepth 1 -type d -exec basename {} \;); do upper=`/bin/echo "$$i" |tr '[:lower:]' '[:upper:]'`; /bin/echo "libs-\$$(CONFIG_USR_LIB_$${upper}) += $$i" >> libs/Makefile.objs.gen; done

quiet_cmd_mkobjlist_apps   = MAKEOBJS_APPS
      cmd_mkobjlist_apps   = rm -f apps/Makefile.objs.gen; for i in $(shell find apps -mindepth 1 -maxdepth 1 -type d -exec basename {} \;); do upper=`/bin/echo "$$i" |tr '[:lower:]' '[:upper:]'`; /bin/echo "app-fw-\$$(CONFIG_APP_$${upper}_FW) += $$i" >> apps/Makefile.objs.gen; /bin/echo "app-dfu-\$$(CONFIG_APP_$${upper}_DFU) += $$i" >> apps/Makefile.objs.gen; done

quiet_cmd_mkobjlist_drvs   = MAKEOBJS_DRVS
      cmd_mkobjlist_drvs   = /bin/echo "DRVSRC_DIR = \$$(PROJ_FILES)/drivers/socs/$(CONFIG_SOCNAME)" > drivers/socs/$(CONFIG_SOCNAME)/Makefile.objs; /bin/echo "drv-y :=" >> drivers/socs/$(CONFIG_SOCNAME)/Makefile.objs; rm -f drivers/socs/$(CONFIG_SOCNAME)/Makefile.objs.gen; for i in $(shell find drivers/socs/$(CONFIG_SOCNAME) -mindepth 1 -maxdepth 1 -type d -exec basename {} \;); do upper=`/bin/echo "$$i" |tr '[:lower:]' '[:upper:]'`; /bin/echo "drv-\$$(CONFIG_USR_DRV_$${upper}) += $$i" >> drivers/socs/$(CONFIG_SOCNAME)/Makefile.objs.gen; done
